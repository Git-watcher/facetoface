Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965
HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送
Cookies，在客户终端，浏览器解析这些Cookies并将它们保存为一个本地文件，它会自动将同一服务器的任
何请求缚上这些Cookies。
Cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客
户端的Cookie支持。Cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。（HTTP无状态协议是
指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能
导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。）
正统的Cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提
示浏览器按照指示生成相应的Cookie。然而纯粹的客户端脚本如JavaScript也可以生成Cookie。而
Cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的Cookie，如果
某个Cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该Cookie附在请求资源的HTTP请求
头上发送给服务器。
Cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设
置过期时间，则表示这个Cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期
为浏览器会话期的Cookie被称为会话Cookie。会话Cookie一般不存储在硬盘上而是保存在内存里，当然这
种行为并不是规范规定的。若设置了过期时间，浏览器就会把Cookie保存到硬盘上，关闭后再次打开浏览器，
这些Cookie仍然有效直到超过设定的过期时间。存储在硬盘上的Cookie可以在不同的浏览器进程间共享，比
如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。
而Session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状
态的方案在客户端也需要保存一个标识，所以Session机制可能需要借助于Cookie机制来达到保存标识的目
的。而Session提供了方便管理全局变量的方式。
Session是针对每一个用户的，变量的值保存在服务器上，用一个SessionID来区分是哪个用户Session
变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用Cookie时，这个值也可能设置为由
get来返回给服务器。
就安全性来说：当你访问一个使用Session 的站点，同时在自己机子上建立一个Cookie，建议在服务器端
的Session机制更安全些，因为它不会任意读取客户存储的信息。
